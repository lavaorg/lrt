/*
Copyright 2017 Verizon. All rights reserved.
Copyright 2018 Larry Rau. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mlog

import (
	"fmt"
	"log"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"

	"github.com/lavaorg/lrt/env"
)

const (
	cversion     = "1"
	cmarker      = "*" + cversion
	cseparator   = "|"
	ctmformat    = "2006/01/02 15:04:05.999999"
	ctmformatlen = len(ctmformat)
)

// information from the environment
type Ext struct {
	CorelationId string `default:"0" desc: "correlates across multiple apps"`
	Debug        bool   `default:false`
	MlogSuppress bool   `default:false`
}

// Severity Enumeration
const (
	ALARM uint8 = iota
	ERROR
	STAT
	EVENT
	INFO
	DEBUG
	UNKNOWN
)

var (
	ext  Ext    // external descriptive info
	name string // process name
	pid  string // os pid
	mlw  mlogwriter

	// these must be initialized early
	stderr = os.Stderr
	stdout = os.Stdout

	// map sev enum to strings
	sevstr []string = []string{
		"ALARM",
		"ERROR",
		"STAT",
		"EVENT",
		"INFO",
		"DEBUG",
		"UNKNOWN",
	}
)

// log initialized at init time
func init() { initialize() }

func initialize() {

	// determine basic application information
	pathx := strings.Split(os.Args[0], "/")
	name = pathx[len(pathx)-1]
	pid = strconv.Itoa(os.Getpid())

	err := env.Load("lrt", &ext)
	if err != nil {
		Emit(ERROR, "could not get env vars:"+err.Error())
		os.Exit(1)
	}

	// force all golog logging to this logger
	log.SetOutput(mlw)
	log.SetFlags(0) // mlog will get date/time + other information
}

// GologWriter
type mlogwriter int

// A Writer to replace the version used by the standard Go log package
func (mlogwriter) Write(buffer []byte) (n int, err error) {

	// For example, the call stack for log.Printf
	// call as obtianed from debugTrace is
	//
	// function calling log method -> go/src/log/log:289
	//                             -> go/src/log/log.go:166
	//                             -> <autogenerated>:1
	//                             -> this method
	//
	// log.Printf call corresponds to "go/src/log/log:289"

	sev := INFO
	// evaluate source
	pc, _, _, ok := runtime.Caller(3)
	if ok {
		fnName := runtime.FuncForPC(pc).Name()
		if strings.HasPrefix(fnName, "log.Fatal") || strings.HasPrefix(fnName, "log.Panic") {
			sev = ALARM
		}
	}
	// get correct file and line
	_, file, line, ok := runtime.Caller(4)
	if !ok {
		file = "???"
		line = 0
	}
	emit(sev, file, line, string(buffer))

	// return ok
	return len(buffer), nil
}

// Enable Debug Messaging
func EnableDebug(flag bool) {
	ext.Debug = flag
}

// Emit debug message if global debug flag set
func Debug(template string, args ...interface{}) {
	if ext.Debug {
		Emit(DEBUG, fmt.Sprintf(template, args))
	}
}

// Emit an Event message
func Event(template string, args ...interface{}) {
	Emit(EVENT, fmt.Sprintf(template, args))
}

// Emit an Info message
func Info(template string, args ...interface{}) {
	Emit(INFO, fmt.Sprintf(template, args))
}

// Emit a Stat message
func Stat(template string, args ...interface{}) {
	Emit(STAT, fmt.Sprintf(template, args))
}

// Emit an Error message
func Error(template string, args ...interface{}) {
	Emit(ERROR, fmt.Sprintf(template, args))
}

// Emit using the alarm severity level
func Alarm(template string, args ...interface{}) {
	Emit(ALARM, fmt.Sprintf(template, args))
}

// Emit a custom type and message (emits to stdout)
func Emit(severity uint8, m string) {

	// get caller statistics
	_, file, line, ok := runtime.Caller(2)
	if !ok {
		file = "???"
		line = 0
	}
	emit(severity, file, line, m)
}

func emit(sev uint8, file string, line int, m string) {

	// determine the shorted-version of the filename
	// and avoid the func call of strings.SplitAfter
	short := file
	for i := len(file) - 1; i > 0; i-- {
		if file[i] == '/' {
			short = file[i+1:]
			break
		}
	}
	file = short

	linx := strconv.Itoa(line)
	fileAndLine := strings.Join([]string{file, linx}, ":")

	// then split into individual lines (by CR)
	lines := strings.Split(m, "\n")

	// format each message from caller statistics
	// and output to the correct stream
	stream := stderr
	if sev > EVENT {
		stream = stdout
	}

	// create a structured log message to emit
	message := cmarker
	if !ext.MlogSuppress {
		timestamp := time.Now().UTC().Format(ctmformat)
		message = strings.Join([]string{
			cmarker, sevstr[sev], ext.CorelationId, pid, name, fileAndLine, timestamp,
		}, cseparator)
	}
	for _, line := range lines {
		if line == "" {
			continue
		}
		// Write message to stdout or stderr
		fmt.Fprintln(stream, message+cseparator+line)
	}
}
