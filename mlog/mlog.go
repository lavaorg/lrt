/*
Copyright 2017 Verizon. All rights reserved.
Copyright 2018 Larry Rau. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mlog

import (
	"fmt"
	"io"
	"log"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var (
	name         string
	application  string
	group        string
	pid          string
	corelationid string
	mesostaskid  string
	severity     uint8

	statWriter  StatWriter
	gologWriter GologWriter
)

const (
	Version   = "1"
	Marker    = "*"
	Separator = "|"
)

// log initialized at init time
func init() { initialize() }

// split for sake of log_test
func initialize() {

	// determine basic application information
	pathx := strings.Split(os.Args[0], "/")
	namex := pathx[len(pathx)-1]

	// pull environment variables
	application = os.Getenv("LRT_APP")
	if application == "" {
		application = namex
	}
	group = os.Getenv("LRT_GROUP")
	if group == "" {
		group = "/" //root group
	}
	corelationid = os.Getenv("LRT_CORELATIONID")
	if corelationid == "" {
		corelationid = "0"
	}

	mesostaskid = os.Getenv("LRT_TASK_ID") //any orchestator task id
	if mesostaskid == "" {
		mesostaskid = "0"
	}

	// initialize log
	name = namex
	pid = strconv.Itoa(os.Getpid())
	severity = INFO
	debug := strings.ToLower(os.Getenv("LRT_ENABLE_DEBUG"))
	if debug == "true" {
		EnableDebug(true)
	}

	// force all golog logging to this logger
	log.SetOutput(gologWriter)
}

// StatWriter
type StatWriter int

// Write
// stat io.Writer implementation
func (self StatWriter) Write(buffer []byte) (n int, err error) {

	// evaluate source
	_, file, line, ok := runtime.Caller(2)
	if !ok {
		file = "???"
		line = 0
	}

	// emit (always)
	emit(STAT, file, line, string(buffer))

	// return ok
	return len(buffer), nil
}

// GologWriter
type GologWriter int

// Write
// Log io.Writer implementation (used exclusivly by golang log)
func (self GologWriter) Write(buffer []byte) (n int, err error) {

	// determine appropriate severity based on
	// buffer content (e.g., panic)
	// default to info
	severityx := INFO

	// For example, the call stack for log.Printf
	// call as obtianed from debugTrace is
	//
	// function calling log method -> go/src/log/log:289
	//                             -> go/src/log/log.go:166
	//                             -> <autogenerated>:1
	//                             -> this method
	//
	// log.Printf call corresponds to "go/src/log/log:289"

	// evaluate source
	pc, file, line, ok := runtime.Caller(3)
	if ok {
		fnName := runtime.FuncForPC(pc).Name()
		if strings.HasPrefix(fnName, "log.Fatal") ||
			strings.HasPrefix(fnName, "log.Panic") {
			severityx = ALARM
		}
	}
	// get correct file and line
	_, file, line, _ = runtime.Caller(4)
	// emit (always)
	emit(severityx, file, line, string(buffer))

	// return ok
	return len(buffer), nil
}

// Severity Enumeration
const (
	NOP uint8 = iota
	ALARM
	ERROR
	STAT
	INFO
	EVENT
	DEBUG
	UNKNOWN
)

// Severity Conversion Tables
var (
	// a conversion table from severity levels to a string
	SeverityToString []string = []string{
		"NOP",
		"ALARM",
		"ERROR",
		"STAT",
		"INFO",
		"EVENT",
		"DEBUG",
		"UNKNOWN",
	}
	// a conversion table from severity levels to a stream
	// this conversion is implemented as a table for the sake of log_test
	severityToStream []io.Writer = []io.Writer{
		os.Stdout, // NOP, placed for documentation purposes
		os.Stderr, // ALARM
		os.Stderr, // ERROR
		os.Stderr, // STAT
		os.Stdout, // INFO
		os.Stderr, // EVENT
		os.Stdout, // DEBUG
		os.Stdout, // UNKNOWN, placed for documentation purposes
	}
)

// Severity
// Returns the severity level
func Severity() uint8 {
	return severity
}

// GetStatWriter
// Return a stat-specific io.Writer
func GetStatWriter() io.Writer {
	return statWriter
}

// Enable Debug Messaging
func EnableDebug(flag bool) {
	if flag {
		severity = DEBUG
	} else {
		severity = EVENT
	}
}

// Debug
// emit using the debug severity level, the only
// optional severity level (see EnableDebug)
func Debug(template string, args ...interface{}) {
	if severity >= DEBUG {
		emit(DEBUG, "", 0, template, args...)
	}
}

// Event
// emit using the event severity level
func Event(template string, args ...interface{}) {
	emit(EVENT, "", 0, template, args...)
}

// Info
// emit using the info severity level
func Info(template string, args ...interface{}) {
	emit(INFO, "", 0, template, args...)
}

// Stat
// emit using the stat severity level
func Stat(template string, args ...interface{}) {
	emit(STAT, "", 0, template, args...)
}

// Error
// emit using the err severity level
func Error(template string, args ...interface{}) {
	emit(ERROR, "", 0, template, args...)
}

// Alarm
// emit using the alarm severity level
func Alarm(template string, args ...interface{}) {
	emit(ALARM, "", 0, template, args...)
}

// ** DEPRECATED
// Emit
func Emit(s uint8, m string) {
	if severity >= s {
		emit(s, "", 0, m)
	}
}

// emit
func emit(severity uint8, file string, line int, template string, args ...interface{}) {

	// get caller statistics
	if file == "" {
		ok := false
		_, file, line, ok = runtime.Caller(2)
		if !ok {
			file = "???"
			line = 0
		}
	}

	// determine the shorted-version of the filename
	// and avoid the func call of strings.SplitAfter
	short := file
	for i := len(file) - 1; i > 0; i-- {
		if file[i] == '/' {
			short = file[i+1:]
			break
		}
	}
	file = short
	linx := strconv.Itoa(line)
	fileAndLine := strings.Join([]string{file, linx}, ":")

	// parse formatted string or use the given template
	// then split into individual lines (by CR)
	var lines []string
	if len(args) > 0 {
		template = fmt.Sprintf(template, args...)
	}
	lines = strings.Split(template, "\n")

	// format each message from caller statistics
	// and output to the correct stream
	stream := severityToStream[severity]

	// create message according to the logging system format specs

	timestamp := time.Now().UTC().Format("2006/01/02 15:04:05.999999999")
	message := strings.Join([]string{
		Marker,
		Version,
		SeverityToString[severity],
		mesostaskid,
		pid,
		group,
		application,
		name,
		corelationid,
		fileAndLine,
		timestamp,
	}, Separator)

	for _, line := range lines {
		if line == "" {
			continue
		}
		// Write message to stdout or stderr
		fmt.Fprintln(stream, message+Separator+line)
	}
}
