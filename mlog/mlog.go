/*
Copyright 2017 Verizon. All rights reserved.
Copyright 2018 Larry Rau. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mlog

import (
	"fmt"
	"io"
	"log"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"

	"github.com/lavaorg/lrt/env"
)

const (
	Version   = "1"
	Marker    = "*"
	Separator = "|"
)

// information from the environment
type Ext struct {
	App          string `default:"noapp"`
	Group        string `default:"nogroup"`
	CorelationId string `default:"0" desc: "correlates across multiple apps"`
	TaskId       string `default:"none" desc:"an orchestrator's id if any"`
	Debug        bool   `default:false`
}

var (
	ext         Ext    // external descriptive info
	name        string // process name
	pid         string // os pid
	statWriter  StatWriter
	gologWriter GologWriter
)

// log initialized at init time
func init() { initialize() }

func initialize() {

	err := env.Load("lrt", &ext)
	if err != nil {
		log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
		log.Fatalf("coul not load mlog env vars:%v", err)
	}

	// determine basic application information
	pathx := strings.Split(os.Args[0], "/")
	name = pathx[len(pathx)-1]
	pid = strconv.Itoa(os.Getpid())

	// force all golog logging to this logger
	log.SetOutput(gologWriter)
}

// StatWriter
type StatWriter int

// Write
// stat io.Writer implementation
func (self StatWriter) Write(buffer []byte) (n int, err error) {

	// evaluate source
	_, file, line, ok := runtime.Caller(2)
	if !ok {
		file = "???"
		line = 0
	}

	// emit (always)
	emit(STAT, file, line, string(buffer))

	// return ok
	return len(buffer), nil
}

// GologWriter
type GologWriter int

// Write
// Log io.Writer implementation (used exclusivly by golang log)
func (self GologWriter) Write(buffer []byte) (n int, err error) {

	// determine appropriate severity based on
	// buffer content (e.g., panic)
	// default to info
	severityx := INFO

	// For example, the call stack for log.Printf
	// call as obtianed from debugTrace is
	//
	// function calling log method -> go/src/log/log:289
	//                             -> go/src/log/log.go:166
	//                             -> <autogenerated>:1
	//                             -> this method
	//
	// log.Printf call corresponds to "go/src/log/log:289"

	// evaluate source
	pc, file, line, ok := runtime.Caller(3)
	if ok {
		fnName := runtime.FuncForPC(pc).Name()
		if strings.HasPrefix(fnName, "log.Fatal") ||
			strings.HasPrefix(fnName, "log.Panic") {
			severityx = ALARM
		}
	}
	// get correct file and line
	_, file, line, _ = runtime.Caller(4)
	// emit (always)
	emit(severityx, file, line, string(buffer))

	// return ok
	return len(buffer), nil
}

// Severity Enumeration
const (
	NOP uint8 = iota
	ALARM
	ERROR
	STAT
	INFO
	EVENT
	DEBUG
	UNKNOWN
)

// Severity Conversion Tables
var (
	// a conversion table from severity levels to a string
	SeverityToString []string = []string{
		"NOP",
		"ALARM",
		"ERROR",
		"STAT",
		"INFO",
		"EVENT",
		"DEBUG",
		"UNKNOWN",
	}
	// a conversion table from severity levels to a stream
	// this conversion is implemented as a table for the sake of log_test
	severityToStream []io.Writer = []io.Writer{
		os.Stdout, // NOP, placed for documentation purposes
		os.Stderr, // ALARM
		os.Stderr, // ERROR
		os.Stderr, // STAT
		os.Stdout, // INFO
		os.Stderr, // EVENT
		os.Stdout, // DEBUG
		os.Stdout, // UNKNOWN, placed for documentation purposes
	}
)

// Return a stat-specific io.Writer
func GetStatWriter() io.Writer {
	return statWriter
}

// Enable Debug Messaging
func EnableDebug(flag bool) {
	ext.Debug = flag
}

// Emit using the debug severity level, the only
// optional severity level (see EnableDebug)
func Debug(template string, args ...interface{}) {
	if ext.Debug {
		Emit(DEBUG, fmt.Sprintf(template, args))
	}
}

// Emit using the event severity level
func Event(template string, args ...interface{}) {
	Emit(EVENT, fmt.Sprintf(template, args))
}

// Emit using the info severity level
func Info(template string, args ...interface{}) {
	Emit(INFO, fmt.Sprintf(template, args))
}

// Emit using the stat severity level
func Stat(template string, args ...interface{}) {
	Emit(STAT, fmt.Sprintf(template, args))
}

// Emit using the err severity level
func Error(template string, args ...interface{}) {
	Emit(ERROR, fmt.Sprintf(template, args))
}

// Emit using the alarm severity level
func Alarm(template string, args ...interface{}) {
	Emit(ALARM, fmt.Sprintf(template, args))
}

func Emit(severity uint8, m string) {

	// get caller statistics
	_, file, line, ok := runtime.Caller(2)
	if !ok {
		file = "???"
		line = 0
	}

	// determine the shorted-version of the filename
	// and avoid the func call of strings.SplitAfter
	short := file
	for i := len(file) - 1; i > 0; i-- {
		if file[i] == '/' {
			short = file[i+1:]
			break
		}
	}
	file = short

	emit(severity, file, line, m)
}

func emit(severity uint8, file string, line int, m string) {

	linx := strconv.Itoa(line)
	fileAndLine := strings.Join([]string{file, linx}, ":")

	// then split into individual lines (by CR)
	lines := strings.Split(m, "\n")

	// format each message from caller statistics
	// and output to the correct stream
	stream := severityToStream[severity]

	// create message according to the logging system format specs

	timestamp := time.Now().UTC().Format("2006/01/02 15:04:05.999999999")
	message := strings.Join([]string{
		Marker,
		Version,
		SeverityToString[severity],
		ext.TaskId,
		pid,
		ext.Group,
		ext.App,
		name,
		ext.CorelationId,
		fileAndLine,
		timestamp,
	}, Separator)

	for _, line := range lines {
		if line == "" {
			continue
		}
		// Write message to stdout or stderr
		fmt.Fprintln(stream, message+Separator+line)
	}
}
